# -*- coding: utf-8 -*-
"""NN - GWO.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PNWANBLfJCqn3ADWnsUD9jAN2ie6czVc

# MLP3 with Grey Wolf Optimizer

### Importing Necessary Modules
"""

import warnings
warnings.filterwarnings("ignore")

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from sklearn import preprocessing
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix
import seaborn as sns
from sklearn.metrics import roc_curve
import random
import copy

"""### Dataset related operations"""

from google.colab import drive
drive.mount('/content/drive')

dataset=pd.read_csv("/content/drive/MyDrive/Neural Networks/weatherHistory.csv")
dataset

df_scaled = preprocessing.scale(dataset)
df_scaled = pd.DataFrame(df_scaled, columns=dataset.columns)
df_scaled['target'] = dataset['Apparent Temperature (C)']
df_scaled.drop('Apparent Temperature (C)',axis=1,inplace=True)
df = df_scaled
X = df.loc[:, df.columns != 'target']
y = df.loc[:, 'target']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=42)

"""### Initialization of Grey Wolves Population"""

def initialization(num_searchagent, dim):
    Positions=np.zeros((num_searchagent, dim))
    for i in range(num_searchagent):
        for j in range(dim):
            Positions[i][j]=round(np.random.uniform(low=0,high=1))
    return Positions

"""### Feed Forward Network"""

def feedForward(pos,X,y,inputdim,hNeurons):
  temp = inputdim * hNeurons
  pos = np.array(pos)
  w1 = pos[:temp].reshape(hNeurons, inputdim)
  w2 = pos[temp:(temp+hNeurons)].reshape(hNeurons, 1)
  temp+=hNeurons
  b1 = pos[temp:(temp+hNeurons)].reshape(hNeurons, 1)
  temp+=hNeurons
  b2 = pos[temp:]
  h1=Sigmoid(np.dot(w1,X.T.to_numpy())+b1)
  h2=np.dot(w2.T,h1)+b2
  h2 = h2.reshape(y.shape,)
  return round(np.abs(y - h2).sum()/np.abs(y.mean()-y).sum(), 6)

def Sigmoid(X):
  return 1/(1+np.exp(-10*(X-0.5)))

"""### GWO Implementation"""

def GWO(SearchAgents_no,Max_iter,ub,lb,Cost_fun,X,y):
  
  dim= (hNeurons*(X.shape[1] + 2)+1)

  Alpha_pos=np.zeros(dim)
  Alpha_score=np.inf
  
  Beta_pos=np.zeros(dim)
  Beta_score=np.inf
  
  Delta_pos=np.zeros(dim)
  Delta_score=np.inf
  
  Positions=initialization(SearchAgents_no,dim)
  # print(Positions)
  
  Convergence_curve=np.zeros(Max_iter)

  l=0
  
  while l<Max_iter:
      
      for i in range(0,SearchAgents_no):
          
          fitness=Cost_fun(Positions[i],X,y,X.shape[1],hNeurons)
          fitness = abs(fitness)

          if fitness<Alpha_score:
              Alpha_score=fitness
              Alpha_pos=Positions[i].copy()
              
          if ((fitness>Alpha_score) and (fitness<Beta_score)):
              Beta_score=fitness
              Beta_pos=Positions[i].copy()
              
          if (fitness>Alpha_score) and (fitness>Beta_score) and (fitness<Delta_score):
              Delta_score=fitness
              Delta_pos=Positions[i].copy()
              
      a=2-l*((2)/Max_iter)
       
      for i in range(0,SearchAgents_no):
          
          for j in range(len(Positions[0])):
              
              r1=random.random()
              r2=random.random()
              A1=2*a*r1-a
              C1=2*r2
              D_alpha=abs(C1*Alpha_pos[j]-Positions[i][j])
            
                              
              r1=random.random()
              r2=random.random()
              A2=2*a*r1-a
              C2=2*r2
              D_beta=abs(C2*Beta_pos[j]-Positions[i][j])
              
              
              r1=random.random()
              r2=random.random()
              A3=2*a*r1-a
              C3=2*r2
              D_delta=abs(C3*Delta_pos[j]-Positions[i][j])


              X1=Alpha_pos[j] - A1*D_alpha
              X2=Beta_pos[j] - A2*D_beta              
              X3=Delta_pos[j] - A3*D_delta
              
              Positions[i][j]= (X1 + X2 + X3)/3
      Convergence_curve[l]=abs(Alpha_score)
      l+=1
      print('Iteration',l,'--',Alpha_score)
  return Alpha_score, Alpha_pos, Convergence_curve

"""### Testing Network"""

def testForward(pos,X,y,inputdim,hNeurons):
  temp = inputdim * hNeurons
  pos = np.array(pos)
  w1 = pos[:temp].reshape(hNeurons, inputdim)
  w2 = pos[temp:(temp+hNeurons)].reshape(hNeurons, 1)
  temp+=hNeurons
  b1 = pos[temp:(temp+hNeurons)].reshape(hNeurons, 1)
  temp+=hNeurons
  b2 = pos[temp:]
  h1=Sigmoid(np.dot(w1,X.T.to_numpy())+b1)
  h2=np.dot(w2.T,h1)+b2
  h2 = h2.reshape(y.shape,)
  dfT = pd.DataFrame(data=h2, columns=['predicted'])
  dfT['Actual'] = y_test.values
  dfT.iloc[0:100].plot()
  print("Testing Error: ", np.abs(y_test - h2).sum()/np.abs(y_test.mean()-y_test).sum())

"""### Running the ANN with GWO"""

Agents=100
MaxIter=50
ub=10
lb=-10
hNeurons = 13
fitness = feedForward
A, B, C = GWO(Agents,MaxIter,ub,lb,fitness,X_train,y_train)
print("Testing Error: ",feedForward(B,X_test,y_test,X_test.shape[1],hNeurons))

plt.plot(C)
plt.show()

testForward(B,X_test,y_test,6,hNeurons)

"""### [Documentation of Algorithm ](https://docs.google.com/document/d/1hTSRVxTti-p8kWtxuSM6xWA8bs89OGC5apciLqtO55g/edit?usp=sharing)"""